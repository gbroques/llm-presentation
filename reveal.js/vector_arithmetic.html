<!DOCTYPE html>
<html>
<head>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.7.0/p5.min.js"></script>
    <style>
        body {
            margin: 0;
            padding: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
        }
        main {
            display: flex;
            justify-content: center;
        }
    </style>
</head>
<body>
    <main></main>
    <script>
        let currentSlide = 0;
        let animationProgress = 0;
        let animating = false;
        let animationDirection = 1; // 1 for forward, -1 for backward
        
        function setup() {
            let size = min(windowWidth, windowHeight);
            createCanvas(size, size);
            
            // Set square line caps for blocky appearance
            drawingContext.lineCap = 'square';
            
            drawVisualization();
        }
        
        function keyPressed() {
            handleKeyPress(key);
        }
        
        // Listen for messages from parent window
        window.addEventListener('message', function(event) {
            if (event.data.type === 'keyPressed') {
                handleKeyPress(event.data.key);
            }
        });
        
        function handleKeyPress(keyValue) {
            if (keyValue === 'ArrowRight' && !animating) {
                if (currentSlide < 2) {
                    currentSlide++;
                    animating = true;
                    animationProgress = 0;
                    animationDirection = 1;
                } else {
                    // Demo is complete, let reveal.js handle the next slide
                    window.parent.postMessage({type: 'demoComplete', direction: 'next'}, '*');
                }
            } else if (keyValue === 'ArrowLeft' && !animating) {
                if (currentSlide > 0) {
                    currentSlide--;
                    animating = true;
                    animationProgress = 0;
                    animationDirection = -1;
                } else {
                    // At beginning, let reveal.js handle the previous slide
                    window.parent.postMessage({type: 'demoComplete', direction: 'prev'}, '*');
                }
            }
        }
        
        function draw() {
            if (animating) {
                animationProgress += 0.02;
                if (animationProgress >= 1) {
                    animationProgress = 1;
                    animating = false;
                }
            }
            drawVisualization();
        }
        
        function windowResized() {
            let size = min(windowWidth, windowHeight);
            resizeCanvas(size, size);
            drawVisualization();
        }
        
        function drawVisualization() {
            background(25, 25, 25); // Dark background
            
            // Scale factors
            let scaleX = width / 400;
            let scaleY = height / 300;
            
            // Axes
            stroke(255); // White axes
            strokeWeight(3);
            line(50 * scaleX, 50 * scaleY, 50 * scaleX, 250 * scaleY);
            line(50 * scaleX, 250 * scaleY, 350 * scaleX, 250 * scaleY);
            
            // Points (scaled) - Updated to ROYGBIV colors
            let paris = {x: 320 * scaleX, y: 117 * scaleY, label: "paris", color: [255, 58, 6], labelPos: "above"};
            let france = {x: 257 * scaleX, y: 220 * scaleY, label: "france", color: [255, 58, 6], labelPos: "below"};
            let italy = {x: 80 * scaleX, y: 194 * scaleY, label: "italy", color: [12, 212, 255], labelPos: "below"};
            let rome = {x: 126 * scaleX, y: 80 * scaleY, label: "rome", color: [12, 212, 255], labelPos: "above"};
            
            let points = [paris, france, italy, rome];
            
            // Circle visual radius (includes stroke)
            let circleRadius = (6 * min(scaleX, scaleY)) + 1; // 6 is radius, +1 for full stroke width
            
            // Calculate the italy->rome vector
            let vectorX = rome.x - italy.x;
            let vectorY = rome.y - italy.y;
            let vectorLen = sqrt(vectorX*vectorX + vectorY*vectorY);
            
            // Calculate shortened vector (to rome's edge, not center)
            let shortVectorX = vectorX - (vectorX/vectorLen) * circleRadius;
            let shortVectorY = vectorY - (vectorY/vectorLen) * circleRadius;
            
            // Draw arrow based on slide
            stroke(0);
            strokeWeight(4);
            
            if (currentSlide === 0) {
                // Slide 0: no arrow, just points
                if (animating && animationDirection === -1) {
                    // Animate arrow disappearing (coming from slide 1)
                    let progress = 1 - animationProgress;
                    let endX = italy.x + vectorX * progress;
                    let endY = italy.y + vectorY * progress;
                    if (progress > 0.1) {
                        drawArrow(italy.x, italy.y, endX, endY, circleRadius);
                    }
                }
                // No arrow drawn when not animating
            } else if (currentSlide === 1) {
                // Slide 1: italy to rome (original vector)
                if (animating) {
                    if (animationDirection === 1) {
                        // Coming from slide 0: animate arrow appearing
                        let progress = animationProgress;
                        let targetX = rome.x - (rome.x - italy.x) / sqrt((rome.x - italy.x)**2 + (rome.y - italy.y)**2) * circleRadius;
                        let targetY = rome.y - (rome.y - italy.y) / sqrt((rome.x - italy.x)**2 + (rome.y - italy.y)**2) * circleRadius;
                        let endX = italy.x + (targetX - italy.x) * progress;
                        let endY = italy.y + (targetY - italy.y) * progress;
                        if (animationProgress > 0.1) {
                            drawArrow(italy.x, italy.y, endX, endY, circleRadius);
                        }
                    } else {
                        // Coming from slide 2: animate vector sliding from france back to italy
                        let progress = 1 - animationProgress;
                        let startX = lerp(italy.x, france.x, progress);
                        let startY = lerp(italy.y, france.y, progress);
                        let endX = startX + shortVectorX;
                        let endY = startY + shortVectorY;
                        drawArrow(startX, startY, endX, endY, circleRadius);
                    }
                } else {
                    // Static arrow from italy to rome's edge
                    let dx = rome.x - italy.x;
                    let dy = rome.y - italy.y;
                    let len = sqrt(dx*dx + dy*dy);
                    dx /= len;
                    dy /= len;
                    let targetX = rome.x - dx * circleRadius;
                    let targetY = rome.y - dy * circleRadius;
                    drawArrow(italy.x, italy.y, targetX, targetY, circleRadius);
                }
            } else {
                // Slide 2: same vector starting from france
                if (animating && animationDirection === 1) {
                    // Animate the vector sliding from italy to france
                    let startX = lerp(italy.x, france.x, animationProgress);
                    let startY = lerp(italy.y, france.y, animationProgress);
                    // Use shortened vector to maintain consistent length
                    let endX = startX + shortVectorX;
                    let endY = startY + shortVectorY;
                    drawArrow(startX, startY, endX, endY, circleRadius);
                } else {
                    // Same shortened vector, but starting from france
                    let endX = france.x + shortVectorX;
                    let endY = france.y + shortVectorY;
                    drawArrow(france.x, france.y, endX, endY, circleRadius);
                }
            }
            
            // Draw points and labels
            textAlign(CENTER, CENTER);
            textSize(20 * min(scaleX, scaleY));
            for (let p of points) {
                // Draw point with transparent fill and stroke (matching word embeddings style)
                fill(p.color[0], p.color[1], p.color[2], 100); // Transparent fill
                stroke(p.color); // Normal color stroke
                strokeWeight(1); // 1px stroke
                circle(p.x, p.y, 12 * min(scaleX, scaleY));
                
                // Draw label
                fill(255); // White text
                noStroke(); // Remove stroke from text
                let labelY = p.labelPos === "above" ? p.y - 20 * min(scaleX, scaleY) : p.y + 20 * min(scaleX, scaleY);
                text(p.label, p.x, labelY);
            }
        }
        
        function drawArrow(x1, y1, x2, y2, radius) {
            // Calculate vector
            let dx = x2 - x1;
            let dy = y2 - y1;
            let len = sqrt(dx*dx + dy*dy);
            
            // If length is too short, don't draw
            if (len < radius) return;
            
            // Normalize
            dx /= len;
            dy /= len;
            
            // Calculate arrowhead size
            let arrowSize = 15 * min(width/400, height/300);
            
            // Start line at edge of starting circle
            let startX = x1 + dx * radius;
            let startY = y1 + dy * radius;
            
            // End line before arrowhead
            let lineEndX = x2 - dx * arrowSize;
            let lineEndY = y2 - dy * arrowSize;
            
            // Draw line from edge of starting circle
            stroke(255); // White line
            strokeWeight(3);
            line(startX, startY, lineEndX, lineEndY);
            
            // Draw arrowhead at x2, y2
            push();
            translate(x2, y2);
            rotate(atan2(dy, dx));
            fill(255); // White arrows
            noStroke();
            triangle(0, 0, -arrowSize, -arrowSize/2.5, -arrowSize, arrowSize/2.5);
            pop();
        }
    </script>
</body>
</html>
