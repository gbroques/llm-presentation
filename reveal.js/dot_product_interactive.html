<!DOCTYPE html>
<html>
<head>
    <title>Interactive Dot Product</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.0/p5.min.js"></script>
</head>
<body>
    <script>
        let greenVector = {x: 1, y: 0};
        let purpleAngle = Math.PI / 4; // 45 degrees
        let isDragging = false;
        let isDraggingScale = false;
        
        function drawArrowhead(x, y, angle) {
            push();
            translate(x, y);
            rotate(angle);
            noStroke();
            triangle(0, 0, -20, -8, -20, 8);
            pop();
        }
        
        function setup() {
            createCanvas(600, 400);
            
            // Set square line caps for blocky appearance
            drawingContext.lineCap = 'square';
            
            // Center the canvas horizontally
            let canvas = document.querySelector('canvas');
            canvas.style.display = 'block';
            canvas.style.margin = '0 auto';
        }
        
        function draw() {
            background(25, 25, 25); // Dark background
            
            // Center coordinates
            let centerX = 150;
            let centerY = 200;
            let scale = 100;
            
            // Draw axes
            stroke(255); // White axes
            strokeWeight(4);
            line(centerX - 120, centerY, centerX + 120, centerY); // x-axis
            line(centerX, centerY - 120, centerX, centerY + 120); // y-axis
            
            // Calculate purple vector
            let purpleVector = {
                x: Math.cos(purpleAngle),
                y: -Math.sin(purpleAngle) // negative for screen coordinates
            };
            
            // Draw vectors with arrowheads
            strokeWeight(6);
            
            // Green vector (fixed at 1,0) - ROYGBIV green
            stroke(141, 255, 10); // #8DFF0A
            fill(141, 255, 10);
            let greenEndX = centerX + greenVector.x * scale;
            let greenEndY = centerY + greenVector.y * scale;
            line(centerX, centerY, greenEndX - 10, greenEndY);
            drawArrowhead(greenEndX, greenEndY, 0);
            
            // Purple vector - ROYGBIV violet
            stroke(245, 0, 235); // #F500EB
            fill(245, 0, 235);
            let purpleEndX = centerX + purpleVector.x * scale;
            let purpleEndY = centerY + purpleVector.y * scale;
            line(centerX, centerY, purpleEndX - 10 * Math.cos(Math.atan2(purpleVector.y, purpleVector.x)), purpleEndY - 10 * Math.sin(Math.atan2(purpleVector.y, purpleVector.x)));
            drawArrowhead(purpleEndX, purpleEndY, Math.atan2(purpleVector.y, purpleVector.x));
            
            // Draw vertical line from purple arrowhead tip to x-axis (dashed)
            stroke(245, 0, 235, 100); // violet with transparency
            strokeWeight(3);
            drawingContext.setLineDash([5, 7]);
            line(purpleEndX, purpleEndY, purpleEndX, centerY);
            drawingContext.setLineDash([]); // reset to solid
            
            // Draw horizontal line from origin to intersection point on x-axis (colored by dot product)
            let currentDotProduct = greenVector.x * purpleVector.x + greenVector.y * purpleVector.y;
            let t = (1 - currentDotProduct) / 2; // Convert from [-1,1] to [1,0] (inverted)
            let r, g, b;
            
            if (t < 0.5) {
                // ROYGBIV red to white (top half - positive dot product)
                r = lerp(255, 255, t * 2);
                g = lerp(58, 255, t * 2);
                b = lerp(6, 255, t * 2);
            } else {
                // White to ROYGBIV blue (bottom half - negative dot product)
                r = lerp(255, 12, (t - 0.5) * 2);
                g = lerp(255, 212, (t - 0.5) * 2);
                b = lerp(255, 255, (t - 0.5) * 2);
            }
            
            stroke(r, g, b);
            strokeWeight(3);
            drawingContext.setLineDash([]);
            line(centerX, centerY, purpleEndX, centerY);
            
            // Draw similarity scale
            let scaleX = 400;
            let scaleY = 50;
            let scaleHeight = 300;
            
            // Gradient rectangle
            for (let i = 0; i < scaleHeight; i++) {
                let t = i / scaleHeight;
                let r, g, b;
                
                if (t < 0.5) {
                    // ROYGBIV red to white (top half)
                    r = lerp(255, 255, t * 2);
                    g = lerp(58, 255, t * 2);
                    b = lerp(6, 255, t * 2);
                } else {
                    // White to ROYGBIV blue (bottom half)
                    r = lerp(255, 12, (t - 0.5) * 2);
                    g = lerp(255, 212, (t - 0.5) * 2);
                    b = lerp(255, 255, (t - 0.5) * 2);
                }
                
                stroke(r, g, b);
                strokeWeight(1);
                line(scaleX, scaleY + i, scaleX + 40, scaleY + i);
            }
            
            // Scale border (top and bottom only)
            noFill();
            stroke(255); // White border
            strokeWeight(2);
            line(scaleX, scaleY, scaleX + 40, scaleY); // top border
            line(scaleX, scaleY + scaleHeight, scaleX + 40, scaleY + scaleHeight); // bottom border
            
            // Black left and right borders
            stroke(0); // Black border
            strokeWeight(2);
            line(scaleX, scaleY, scaleX, scaleY + scaleHeight); // left border
            line(scaleX + 40, scaleY, scaleX + 40, scaleY + scaleHeight); // right border
            
            // Labels
            fill(255); // White text
            noStroke();
            textAlign(CENTER);
            textSize(16);
            text("Similar", scaleX + 20, scaleY - 10);
            text("Dissimilar", scaleX + 20, scaleY + scaleHeight + 20);
            
            // Scale markers with dark outlines for visibility
            // Top marker (1)
            stroke(0); // Black outline
            strokeWeight(4);
            line(scaleX - 5, scaleY, scaleX + 45, scaleY);
            stroke(255); // White fill
            strokeWeight(2);
            line(scaleX - 5, scaleY, scaleX + 45, scaleY);
            
            // Middle marker (0)
            stroke(0); // Black outline
            strokeWeight(4);
            line(scaleX - 5, scaleY + scaleHeight/2, scaleX + 45, scaleY + scaleHeight/2);
            stroke(255); // White fill
            strokeWeight(2);
            line(scaleX - 5, scaleY + scaleHeight/2, scaleX + 45, scaleY + scaleHeight/2);
            
            // Bottom marker (-1)
            stroke(0); // Black outline
            strokeWeight(4);
            line(scaleX - 5, scaleY + scaleHeight, scaleX + 45, scaleY + scaleHeight);
            stroke(255); // White fill
            strokeWeight(2);
            line(scaleX - 5, scaleY + scaleHeight, scaleX + 45, scaleY + scaleHeight);
            
            textAlign(LEFT);
            textSize(12);
            fill(255); // White text
            noStroke();
            textStyle(NORMAL);
            text("1", scaleX + 55, scaleY + 5);
            text("0", scaleX + 55, scaleY + scaleHeight/2 + 5);
            text("-1", scaleX + 55, scaleY + scaleHeight + 5);
            
            // Calculate and display dot product
            let dotProduct = greenVector.x * purpleVector.x + greenVector.y * purpleVector.y;
            
            // Draw dot product line on scale with outline
            let lineY = scaleY + scaleHeight/2 - (dotProduct * scaleHeight/2);
            stroke(0); // Black outline
            strokeWeight(5);
            line(scaleX - 10, lineY, scaleX + 50, lineY);
            stroke(255); // White line
            strokeWeight(3);
            line(scaleX - 10, lineY, scaleX + 50, lineY);
            
            // Display dot product value next to the line
            fill(255); // White text
            noStroke();
            textAlign(RIGHT);
            textSize(14);
            textStyle(NORMAL);
            text(dotProduct.toFixed(2), scaleX - 15, lineY + 5);
        }
        
        function mousePressed() {
            let centerX = 150;
            let centerY = 200;
            let scaleX = 400;
            let scaleY = 50;
            let scaleHeight = 300;
            
            // Check if clicking on the vector area
            let dist = Math.sqrt((mouseX - centerX) ** 2 + (mouseY - centerY) ** 2);
            if (dist < 150) {
                isDragging = true;
                return;
            }
            
            // Check if clicking on the scale
            if (mouseX >= scaleX - 10 && mouseX <= scaleX + 50 && 
                mouseY >= scaleY && mouseY <= scaleY + scaleHeight) {
                isDraggingScale = true;
                updateAngleFromScale();
            }
        }
        
        function updateAngleFromScale() {
            let scaleY = 50;
            let scaleHeight = 300;
            
            // Convert click position to dot product value
            let clickY = mouseY - scaleY;
            let targetDotProduct = 1 - (clickY / scaleHeight) * 2; // Convert to -1 to 1 range
            
            // Calculate angle for this dot product (green vector is at 0 degrees)
            // dot product = cos(angle) when both vectors have length 1
            let targetAngle = Math.acos(Math.max(-1, Math.min(1, targetDotProduct)));
            
            // Keep the same quadrant preference (negative y for screen coordinates)
            if (purpleAngle > Math.PI) {
                targetAngle = 2 * Math.PI - targetAngle;
            }
            
            purpleAngle = targetAngle;
        }
        
        function mouseDragged() {
            if (isDragging) {
                let centerX = 150;
                let centerY = 200;
                purpleAngle = Math.atan2(-(mouseY - centerY), mouseX - centerX);
            } else if (isDraggingScale) {
                updateAngleFromScale();
            }
        }
        
        function mouseReleased() {
            isDragging = false;
            isDraggingScale = false;
        }
    </script>
</body>
</html>
